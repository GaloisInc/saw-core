-- Grammar for the core prelude types.
--
-- We use double colons "::" to represent the type constraint on the core symbols.
--   e.g., "Bool :: Type 0" indicates "Bool" has type "Type 0"
-- Functions use "->" to separate arguments from result.
--   e.g., "f :: Bool -> Bool -> Bool"indicates "f" is a binary operation on Booleans.
--
-- Single colons ":" are used for for scoping variables to be used in subsequent arguments.
--   "f :: n : Integer -> Signed n -> Signed n"
-- This  indicates "f" is a function that takes an integer argument "n", and returns a function
-- that takes "n"-bit signed integer and returns another "n"-bit signed integer.
--
-- We prefix the parameter with a single question mark (e.g., "?(n : Integer)") to indicate
-- the parameter is not passed explicitly, but should be inferred by type unification.
--
-- We prefix the parameter with two question marks (e.g., "??(Ord a)") to indicate the
-- parameter is not passed explicitly, but should be obtained by finding a unique term with
-- that type in the surrounding context.  If there are multiple such terms, then fail.
--
-- We use a parameter with three question marks (e.g., "???(Assert (eq x y))") to denote
-- parameters that are not explicitly passed, but must be found to show that the expression
-- is well formed.  This is used to ensure the index is valid when reading or updating an array.

-- Booleans
data Bool :: sort 0 where {
    True :: Bool;
    False :: Bool;
  }

-- Could be derived from data declaration.
ite :: ?(a :: sort 0) -> Bool -> a -> a -> a;

-- assert is a function that maps "True" to the inhabited type "TrueProp" and
-- "False" to the uninhabited type "FalseProp" 
Assert :: Bool -> sort 0;

-- Inhabited type for true propositions.
data TrueProp :: sort 0 where {
    AtomicProof :: TrueProp;
  }

-- Uninhabited type 
data FalseProp :: sort 0 where {
  }

-- Ordering "typeclass"
data Ord :: sort 0 -> sort 0 where {
   OrdInstance :: ?(a :: sort 0)
               -> (a -> a -> Bool) -- Less-than-or-equal function.
               -> Ord a;
  }

--leq :: ?(a :: sort 0) -> ??(Ord a) -> a -> a -> Bool;
--leq ??(OrdInstance f) = f;

--lt  :: ?(a :: sort 0) -> ??(Ord a) -> a -> a -> Bool;
--lt ??(OrdInstance f) x y = not (leq y x);

--geq :: ?(a :: sort 0) -> ??(Ord a) -> a -> a -> Bool;
--geq ??(OrdInstance f) x y = leq y x;

--gt  :: ?(a :: sort 0) -> ??(Ord a) -> a -> a -> Bool;
--gt ??(OrdInstance f) x y = not (leq x y);

-- False becomes before true.
boolOrdInstance :: Ord Bool;

-- Numeric operations.
data Num :: sort 0 -> sort 0 where {
   NumInstance 
         :: ?(a :: sort 0)
         -> #{ neg :: a -> a;
               add :: a -> a -> a;
               sub :: a -> a -> a;
               mul :: a -> a -> a;
               div :: a -> a -> a;
               rem :: a -> a -> a;
             }
         -> Num a;
  }

neg :: ?(a :: sort 0) -> ??(Num a) -> a -> a;
neg ??(NumInstance r) = r.neg;

add :: ?(a :: sort 0) -> ??(Num a) -> a -> a -> a;
add ??(NumInstance r) = r.add;

sub :: ?(a :: sort 0) -> ??(Num a) -> a -> a -> a;
sub ??(NumInstance r) = r.sub;

mul :: ?(a :: sort 0) -> ??(Num a) -> a -> a -> a;
mul ??(NumInstance r) = r.mul;

div :: ?(a :: sort 0) -> ??(Num a) -> a -> a -> a;
div ??(NumInstance r) = r.div;

rem :: ?(a :: sort 0) -> ??(Num a) -> a -> a -> a;
rem ??(NumInstance r) = r.rem;


data Bits :: sort 0 -> sort 0 where {
   BitsInstance :: ?(a :: sort 0)
                -> #{ not     :: a -> a;
                      and     :: a -> a -> a;
                      or      :: a -> a -> a;
                      xor     :: a -> a -> a;
                      implies :: a -> a -> a;
                      shl     :: a -> a -> a;
                      shr     :: a -> a -> a;
                    }
                -> Bits a;
  }

not :: ?(a :: sort 0) -> ??(Bits a) -> a -> a;
not ??(BitsInstance r) = r.not;

and :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
and ??(BitsInstance r) = r.and;

or :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
or ??(BitsInstance r) = r.or;

xor :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
xor ??(BitsInstance r) = r.xor;

implies :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
implies ??(BitsInstance r) = r.imples;

shl :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
shl ?(a :: sort 0) ??(BitsInstance r) = r.shl;

shr :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
shr ?(a :: sort 0) ??(r :: BitsInstance r) = r.shr;

boolBitsInstance :: Bits Bool;

-- Integers
Integer :: sort 0;
-- There are implicit constructors from integer literals.
integerEqInstance   :: Eq   Integer;
integerOrdInstance  :: Ord  Integer;
integerNumInstance  :: Num  Integer;
integerBitsInstance :: Bits Integer;

-- "Array n a" is an array of n elements, each with type "a".
Array :: (n :: Integer) -> sort 0 -> sort 0;
-- For each natural number n, there is an implicit constructor
-- [x0,...,x(n-1)] for creating an array with length n.
arrayEqInstance   :: ?(n :: Integer) -> ?(e :: sort 0) -> ??(Eq e)   -> Eq   (Array n e);
arrayOrdInstance  :: ?(n :: Integer) -> ?(e :: sort 0) -> ??(Ord e)  -> Ord  (Array n e);
arrayBitsInstance :: ?(n :: Integer) -> ?(e :: sort 0) -> ??(Bits e) -> Bits (Array n e);

-- Get and set an individual element in an array.
-- The assertions are used to ensure that get and set are given valid arguments.
get :: ?(n :: Integer) -> ?(e :: sort 0)
    -> Array n e -> (i::Integer) -> ???(Assert (and (leq 0 i) (lt i n))) -> e;
set :: ?(n :: Integer) -> ?(a :: sort 0)
    -> Array n a -> (i::Integer) -> a -> ???(Assert (and (leq 0 i) (lt i n)))
    -> Array n a;

-- Function for generating an array.
generate :: (n :: Integer)
         -> ???(Assert (leq 0 n))
         -> ?(e :: sort 0) 
         -> ((i :: Integer) -> ???(Assert (and (leq 0 i) (lt i n))) -> e) 
         -> Array n e;

-- | Select a range [l,..,l+n] of values from the array.
select :: ?(l :: Integer) -> (i n :: Integer) -> ?(e :: sort 0)
       -> ???(Assert (and (and (leq 0 i) (leq 0 n)) (leq (add i n) l))) 
       -> Array l e -> Array n e;
select =
  \?(l :: Integer) (i :: Integer) (n :: Integer) ?(e :: sort 0) ???(_::TrueProp) (a::Array l e) ->    generate n ???AtomicProof ?e (\(j :: Integer) ???(_::TrueProp) ->
      get ?n ?e a (add i j) ???AtomicProof);

-- replicate n x returns an array with n copies of x.
replicate :: (n :: Integer)
          -> ???(Assert (leq 0 n))
          -> ?(e :: sort 0) -> e -> Array n e;
replicate = \(n :: Integer) ???(_::TrueProp) ?(e :: sort 0) (v :: e) ->
  generate n ???AtomicProof ?e (\(_::Integer) ???(_::TrueProp) -> v);

-- Concatenate arrays together.
join  :: ?(m n :: Integer) -> ?(e :: sort 0) -> Array m (Array n e) -> Array (mul m n) e;
join = \?(m :: Integer) ?(n :: Integer) ?(e :: sort 0) a ->
  generate (mul m n) ???AtomicProof ?e (\i ?_ ->
    get ?n
        ?e
        (get ?m ?(Array n e) a (div i n) ???AtomicProof)
        (rem i n)
        ???AtomicProof);

-- Split array into list
split :: ?(m n :: Integer) -> ?(e :: sort 0) -> Array (mul m n) e -> Array m (Array n e);
split = \?(m :: Integer) ?(n :: Integer) ?(e :: sort 0) a ->
  generate m ???AtomicProof ?(Array n e) (\(i :: Integer) ???_ ->
    generate n ???AtomicProof ?e (\(j :: Integer) ???_ ->
      get ?(mul m n) ?e a (add (mul n i) j) ???AtomicProof));

-- Append two arrays together.
append :: ?(m n :: Integer) -> ?(e :: sort 0) 
       -> Array m e -> Array n e -> Array (plus m n) e;
append =
  \?(m :: Integer) ?(n :: Integer) ?(e :: sort 0) (x :: Array m e) (y :: Array n e) ->
     generate (plus m n) ???AtomicProof ?e (\(i :: Integer) ???_ ->
       ite ?e
           (lt ?Integer ??integerOrdInstance i m)
           (get ?m ?e x i ???AtomicProof)
           (get ?n ?e y (sub i m) ???AtomicProof));

-- "Signed n" and "Unsigned n" represent bitvectors with length n
-- representing signed and unsigned integers.
Signed   :: (n :: Integer) -> sort 0;
Unsigned :: (n :: Integer) -> sort 0;
-- These are equivalent to arrays of Booleans, but can perform arithmetic.
signedOrdInstance    :: ?(n :: Integer) -> Ord (Signed n);
signedNumInstance    :: ?(n :: Integer) -> Num (Signed n);
signedBitsInstance   :: ?(n :: Integer) -> Bits (Signed n);
unsignedOrdInstance  :: ?(n :: Integer) -> Ord (Unsigned n);
unsignedNumInstance  :: ?(n :: Integer) -> Num (Unsigned n);
unsignedBitsInstance :: ?(n :: Integer) -> Bits (Unsigned n);

-- Convert between bitvectors and integers.
signedToInteger   :: ?(n :: Integer) -> Signed n   -> Integer;
unsignedToInteger :: ?(n :: Integer) -> Unsigned n -> Integer;
integerToSigned   :: ?(n :: Integer) -> ???(Assert (leq 0 n)) -> Integer -> Signed n;
integerToUnsigned :: ?(n :: Integer) -> ???(Assert (leq 0 n)) -> Integer -> Unsigned n;

-- Convert between bitvectors and arrays of bits.
-- Integers are stored with most-significant bit first (aka. in byte 0).
signedToArray   :: ?(n :: Integer) -> Signed   n   -> Array n Bool;
unsignedToArray :: ?(n :: Integer) -> Unsigned n   -> Array n Bool;
arrayToSigned   :: ?(n :: Integer) -> Array n Bool -> Signed n;
arrayToUnsigned :: ?(n :: Integer) -> Array n Bool -> Unsigned n;

-- | Convert between two signed representations.
-- This is implemented by using arrays so that the result can still be bit-blasted.
signedResize :: ?(x y :: Integer)
             -> ???(Assert (and (leq 1 x) (leq 1 y)))
             -> Signed x -> Signed y;
-- Simple definition (if bit-blasting doesn't matter)
-- signedToSigned s = integerToSigned (signedToInteger s)
-- Complex definition (supports bit-blasting).
signedResize = 
  \?(x :: Integer) ?(y :: Integer) ???_ (s :: Signed x) ->
     arrayToSigned ?y
       ((\(a :: Array x Bool) ->
           ite ?(Signed y)
               (leq ?Integer ??integerOrdInstance x y)
               (append ?(sub y x)
                       ?x
                       ?Bool
                       (replicate (sub y x)
                                  ???AtomicProof
                                  ?Bool
                                  (get ?x ?Bool a 0 ???AtomicProof))
                       a)
               (select ?x 0 y ?Bool ???AtomicProof a))
        (signedToArray ?x s));

signedToUnsigned :: ?(x :: Integer)
                 -> ???(Assert (leq 1 x))
                 -> Signed x -> Unsigned x;

unsignedToSigned :: ?(x :: Integer)
                 -> ???(Assert (leq 1 x))
                 -> Unsigned x -> Signed x;