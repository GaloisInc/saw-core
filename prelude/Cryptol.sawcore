--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on type Nat

widthNat :: Nat -> Nat;
subNat :: Nat -> Nat -> Nat;

--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

TCWidth :: Num -> Num;
TCWidth (TCNum n) = TCNum (widthNat n);
TCWidth TCInf = TCInf;

TCLg2 :: Num -> Num;

TCAdd :: Num -> Num -> Num;
TCAdd (TCNum x) (TCNum y) = TCNum (addNat x y);
TCAdd (TCNum _) TCInf = TCInf;
TCAdd TCInf _ = TCInf;

TCSub :: Num -> Num -> Num;
TCSub (TCNum x) (TCNum y) = TCNum (subNat x y);
-- TODO: other cases

TCMul :: Num -> Num -> Num;
TCMul (TCNum x) (TCNum y) = TCNum (mulNat x y);
TCMul (TCNum x) TCInf = ite Num (equalNat 0 x) (TCNum 0) TCInf;
TCMul TCInf (TCNum y) = ite Num (equalNat 0 y) (TCNum 0) TCInf;
TCMul TCInf TCInf = TCInf;

TCDiv :: Num -> Num -> Num;
TCMod :: Num -> Num -> Num;
TCExp :: Num -> Num -> Num;

TCMin :: Num -> Num -> Num;
TCMin (TCNum x) (TCNum y) = TCNum (minNat x y);
TCMin (TCNum x) TCInf = TCNum x;
TCMin TCInf (TCNum y) = TCNum y;
TCMin TCInf TCInf = TCInf;

TCMax :: Num -> Num -> Num;

TCLenFromThen :: Num -> Num -> Num -> Num;
TCLenFromThenTo :: Num -> Num -> Num -> Num;

--------------------------------------------------------------------------------
-- Possibly unbounded sequence indexes

data Index :: Num -> sort 0 where {
    IndexNum :: (n :: Nat) -> Fin n -> Index (TCNum n);
    IndexInf :: Nat -> Index TCInf;
  }

unIndexNum :: (n :: Nat) -> Index (TCNum n) -> Fin n;
unIndexNum _ (IndexNum _ i) = i;

unIndexInf :: Index TCInf -> Nat;
unIndexInf (IndexInf i) = i;

indexMinL :: (m n :: Num) -> Index (TCMin m n) -> Index m;
--indexMinL (TCNum m) (TCNum n) i = ...
indexMinL (TCNum m) TCInf i = i;
indexMinL TCInf (TCNum n) i = IndexInf (finFront n (unIndexNum n i));
indexMinL TCInf TCInf i = i;

indexMinR :: (m n :: Num) -> Index (TCMin m n) -> Index n;
--indexMinR (TCNum m) (TCNum n) i = ...
indexMinR (TCNum m) TCInf i = IndexInf (finFront m (unIndexNum m i));
indexMinR TCInf (TCNum n) i = i;
indexMinR TCInf TCInf i = i;

indexSplit :: (m n :: Num) -> Index (TCMul m n) -> #(Index m, Index n);

indexFst :: (m n :: Num) -> Index (TCMul m n) -> Index m;
indexFst (TCNum m) (TCNum n) i = IndexNum m (finFst m n (unIndexNum (mulNat m n) i));
-- TODO: more cases

indexSnd :: (m n :: Num) -> Index (TCMul m n) -> Index n;
indexSnd (TCNum m) (TCNum n) i = IndexNum n (finSnd m n (unIndexNum (mulNat m n) i));
-- TODO: more cases

--------------------------------------------------------------------------------
-- Possibly infinite sequences

data Seq :: Num -> sort 0 -> sort 0 where {
    SeqNum :: (n :: Nat) -> (a :: sort 0) -> Vec n a -> Seq (TCNum n) a;
    SeqInf :: (a :: sort 0) -> (Nat -> a) -> Seq TCInf a;
  }

unSeqNum :: (n :: Nat) -> (a :: sort 0) -> Seq (TCNum n) a -> Vec n a;
unSeqNum _ _ (SeqNum _ _ v) = v;

unSeqInf :: (a :: sort 0) -> Seq TCInf a -> Nat -> a;
unSeqInf _ (SeqInf _ f) = f;

make :: (n :: Num) -> (a :: sort 0) -> (Index n -> a) -> Seq n a;
make (TCNum n) a f = SeqNum n a (Prelude.generate n a (\(i :: Fin n) -> f (IndexNum n i)));
make TCInf a f = SeqInf a (\(i :: Nat) -> f (IndexInf i));

peek :: (n :: Num) -> (a :: sort 0) -> Seq n a -> Index n -> a;
peek (TCNum n) a v i = Prelude.get n a (unSeqNum n a v) (unIndexNum n i);
peek TCInf a v i = unSeqInf a v (unIndexInf i);

bvToSeq :: (n :: Nat) -> bitvector n -> Seq (TCNum n) Bool;
bvToSeq n x = SeqNum n Bool x;

bvOfSeq :: (n :: Nat) -> Seq (TCNum n) Bool -> bitvector n;
bvOfSeq n x = unSeqNum n Bool x;

--------------------------------------------------------------------------------
-- Predicate symbols

PEqual :: Num -> Num -> sort 0;
PNeq   :: Num -> Num -> sort 0;
PGeq   :: Num -> Num -> sort 0;

data PFin :: Num -> sort 0 where {
    PFinNum :: (n :: Nat) -> PFin (TCNum n);
  }

pfinWidth :: (n :: Num) -> PFin n -> PFin (TCWidth n);
pfinWidth _ (PFinNum n) = PFinNum (widthNat n);

pfinSub :: (m n :: Num) -> PFin m -> PFin n -> PFin (TCSub m n);
pfinSub _ _ (PFinNum m) (PFinNum n) = PFinNum (subNat m n);

-- PHas Selector

data PArith :: sort 0 -> sort 0 where {
    PArithWord :: (n :: Num) -> PFin n -> PArith (Seq n Bool);
    PArithSeq :: (n :: Num) -> (a :: sort 0) -> PArith a -> PArith (Seq n a);
    PArithPair :: (a b :: sort 0) -> PArith a -> PArith b -> PArith #(a, b);
  }

data PCmp :: sort 0 -> sort 0 where {
    PCmpBit :: PCmp Bool;
    PCmpSeq :: (n :: Num) -> (a :: sort 0) -> PFin n -> PCmp a -> PCmp (Seq n a);
    PCmpPair :: (a b :: sort 0) -> PCmp a -> PCmp b -> PCmp #(a, b);
  }

theNat :: (m :: Num) -> PFin m -> Nat;
--theNat _ (Instance_PFin_TCNum n) = n;

theVec :: (m :: Num) -> (a :: sort 0) -> (p :: PFin m) -> Seq m a -> Vec (theNat m p) a;
--theVec _ a (Instance_PFin_TCNum n) xs = vecOfSeq a n xs;

--------------------------------------------------------------------------------
-- Auxiliary functions

EProofApp :: (a :: sort 0) -> a;
ECast :: (a b :: sort 0) -> a -> b;

EList :: (a :: sort 0) -> (n :: Nat) -> Vec n a -> Seq (TCNum n) a;
EList a n v = SeqNum n a v;

EListSel :: (a :: sort 0) -> (n :: Num) -> Seq n a -> Nat -> a;
EIf :: (a :: sort 0) -> Bool -> a -> a -> a;

--------------------------------------------------------------------------------
-- List comprehensions

-- TODO: use Prelude one
uncurry :: (a b c :: sort 0) -> (a -> b -> c) -> (#(a, b) -> c);
uncurry a b c f = (\(x :: #(a, b)) -> f (x.1) (x.2));

from :: (a b :: sort 0) -> (m n :: Num) -> Seq m a -> (a -> Seq n b) -> Seq (TCMul m n) #(a, b);
from a b m n xs f =
  make (TCMul m n) #(a, b)
    (\(i :: Index (TCMul m n)) ->
      (peek m a xs (indexFst m n i),
       peek n b (f (peek m a xs (indexFst m n i))) (indexSnd m n i)));

single :: (a :: sort 0) -> a -> Seq (TCNum 1) a;
single a x = make (TCNum 1) a (\(i :: Index (TCNum 1)) -> x);

mlet :: (a b :: sort 0) -> (n :: Num) -> a -> (a -> Seq n b) -> Seq n #(a, b);
mlet a b n x f = make n #(a, b) (\(i :: Index n) -> (x, peek n b (f x) i));

zip :: (a b :: sort 0) -> (m n :: Num) -> Seq m a -> Seq n b -> Seq (TCMin m n) #(a, b);
zip a b m n xs ys =
  make (TCMin m n) #(a, b)
    (\(i :: Index (TCMin m n)) ->
      (peek m a xs (indexMinL m n i), peek n b ys (indexMinR m n i)));

map :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> Seq n a -> Seq n b;
map a b n f xs = make n b (\(i :: Index n) -> f (peek n a xs i));

--------------------------------------------------------------------------------
-- Arith functions

bvBinary :: (n :: Nat) -> (bitvector n -> bitvector n -> bitvector n)
  -> Seq (TCNum n) Bool -> Seq (TCNum n) Bool -> Seq (TCNum n) Bool;
bvBinary n f xs ys = bvToSeq n (f (bvOfSeq n xs) (bvOfSeq n ys));

seqBinary :: (n :: Num) -> (a :: sort 0) -> (a -> a -> a) -> Seq n a -> Seq n a -> Seq n a;
seqBinary n a f xs ys = make n a (\(i :: Index n) -> f (peek n a xs i) (peek n a ys i));

pairBinary :: (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b) -> #(a, b) -> #(a, b) -> #(a, b);
pairBinary a b f g x y = (f x.1 y.1, g x.2 y.2);

arithBinary :: ((n :: Nat) -> bitvector n -> bitvector n -> bitvector n)
         -> (a :: sort 0) -> PArith a -> a -> a -> a;
arithBinary bvOp _ (PArithWord _ (PFinNum n)) = bvBinary n (bvOp n);
arithBinary bvOp _ (PArithSeq n a pa) = seqBinary n a (arithBinary bvOp a pa);
arithBinary bvOp _ (PArithPair a b pa pb) =
  pairBinary a b (arithBinary bvOp a pa) (arithBinary bvOp b pb);

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ECDemote :: (val bits :: Num) -> PFin val -> PFin bits -> PGeq bits (TCWidth val) -> Seq bits Bool;
ECDemote _ _ (PFinNum val) (PFinNum bits) _ = bvToSeq bits (bvNat bits val);

-- Arith
ECPlus  :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECPlus = arithBinary bvAdd;

ECMinus :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECMinus = arithBinary bvSub;

ECMul :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECMul = arithBinary bvMul;

ECDiv   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECMod   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECExp   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECLg2   :: (a :: sort 0) -> PArith a -> a -> a;
ECNeg   :: (a :: sort 0) -> PArith a -> a -> a;

-- Cmp
ECLt    :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ECGt    :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ECLtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ECGtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;

ECEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ECEq _ PCmpBit = boolEq;
--ECEq _ (PCmpSeq n a pn pa) = allSeq n 
ECEq _ (PCmpPair a b pa pb) =
  (\(x :: #(a, b)) -> \(y :: #(a, b)) -> and (ECEq a pa x.1 y.1) (ECEq b pb x.2 y.2));

ECNotEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;

ECFunEq    :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ECFunEq a b pb f g x = ECEq b pb (f x) (g x);

ECFunNotEq :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ECFunNotEq a b pb f g x = ECNotEq b pb (f x) (g x);

ECMin :: (a :: sort 0) -> PCmp a -> a -> a -> a;
ECMax :: (a :: sort 0) -> PCmp a -> a -> a -> a;

-- Logic
ECAnd   :: (a :: sort 0) -> a -> a -> a;
ECOr    :: (a :: sort 0) -> a -> a -> a;
ECXor   :: (a :: sort 0) -> a -> a -> a;
ECCompl :: (a :: sort 0) -> a -> a;
ECZero  :: (a :: sort 0) -> a;

-- Sequences
ECShiftL :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;
ECShiftR :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;
ECRotL   :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;
ECRotR   :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;

ECCat :: (m n :: Num) -> (a :: sort 0) -> PFin m -> Seq m a -> Seq n a -> Seq (TCAdd m n) a;
ECSplitAt :: (m n :: Num) -> (a :: sort 0) -> PFin m -> Seq (TCAdd m n) a -> #(Seq m a, Seq n a);
ECJoin    :: (m n :: Num) -> (a :: sort 0) -> PFin n -> Seq m (Seq n a) -> Seq (TCMul m n) a;
ECSplit   :: (m n :: Num) -> (a :: sort 0) -> PFin n -> Seq (TCMul m n) a -> Seq m (Seq n a);

ECReverse   :: (n :: Num) -> (a :: sort 0) -> PFin n -> Seq n a -> Seq n a;
ECTranspose :: (m n :: Num) -> (a :: sort 0) -> Seq m (Seq n a) -> Seq n (Seq m a);

ECAt :: (n :: Num) -> (a :: sort 0) -> (m :: Num) -> Seq n a -> Seq m Bool -> a;
ECAtRange :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> PFin i -> Seq n a -> Seq m (Seq i Bool) -> Seq m a;
ECAtBack :: (n :: Num) -> (a :: sort 0) -> (m :: Num) -> PFin n -> Seq n a -> Seq m Bool -> a;
ECAtRangeBack :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> PFin n -> Seq n a -> Seq m (Seq i Bool) -> Seq m a;

-- Static word sequences
ECFromThen :: (first next bits len :: Num) -> PFin first -> PFin next -> PFin bits
           -> PGeq bits (TCWidth first) -> PGeq bits (TCWidth next)
           -> PEqual (TCLenFromThen first next bits) len
           -> Seq len (Seq bits Bool);

ECFromTo :: (first last bits :: Num) -> PFin last -> PFin bits
         -> PGeq last first -> PGeq bits (TCWidth last)
         -> Seq (TCAdd (TCNum 1) (TCSub last first)) (Seq bits Bool);

-- Infinite word sequences
ECInfFrom :: (n :: Num) -> PFin n -> Seq n Bool -> Seq TCInf (Seq n Bool);
ECInfFrom _ (PFinNum n) (SeqNum _ _ w) =
  SeqInf (Seq (TCNum n) Bool) (\(i :: Nat) -> SeqNum n Bool (bvAdd n w (bvNat n i)));

ECInfFromThen :: (n :: Num) -> PFin n -> Seq n Bool -> Seq n Bool -> Seq TCInf (Seq n Bool);

-- Run-time error
ECError :: (a :: sort 0) -> (len :: Num) -> PFin len -> Seq len (Seq (TCNum 8) Bool) -> a;

-- Polynomials
ECPMul :: (a b :: Num) -> PFin a -> PFin b -> Seq a Bool -> Seq b Bool
       -> Seq (TCSub (TCMax (TCNum 1) (TCAdd a b)) (TCNum 1)) Bool;

ECPDiv :: (a b :: Num) -> PFin a -> PFin b
       -> Seq a Bool -> Seq b Bool -> Seq a Bool;

ECPMod :: (a b :: Num) -> PFin a -> PFin b
       -> Seq a Bool -> Seq (TCAdd (TCNum 1) b) Bool -> Seq b Bool;

-- Random values
ECRandom :: (a :: sort 0) -> Seq (TCNum 32) Bool -> a;


--------------------------------------------------------------------------------
-- Extra functions that appear after rewriting

bvOfSeq_bvToSeq ::
  (n :: Nat) -> (x :: bitvector n) -> Eq (bitvector n) (bvOfSeq n (bvToSeq n x)) x;

peek_make ::
  (n :: Num) -> (a :: sort 0) -> (f :: Index n -> a) -> (i :: Index n)
  -> Eq a (peek n a (make n a f) i) (f i);

--------------------------------------------------------------------------------
-- Rewrite rules


-- Num operations

-- Boolean operations
ECAnd_Bool :: Eq (Bool -> Bool -> Bool) (ECAnd Bool) and;
ECOr_Bool :: Eq (Bool -> Bool -> Bool) (ECOr Bool) or;

-- Bitvector operations
ECCompl_Seq_TCNum_Bool :: (n :: Nat) -> (x :: Seq (TCNum n) Bool)
  -> Eq (Seq (TCNum n) Bool) (ECCompl (Seq (TCNum n) Bool) x) (bvToSeq n (bvNot n (bvOfSeq n x)));

ECEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECEq (Seq (TCNum n) Bool) p x y) (bvEq n (bvOfSeq n x) (bvOfSeq n y));

ECGtEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECGtEq (Seq (TCNum n) Bool) p x y) (bvuge n (bvOfSeq n x) (bvOfSeq n y));

ECLt_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECLt (Seq (TCNum n) Bool) p x y) (bvult n (bvOfSeq n x) (bvOfSeq n y));

ECLtEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECLtEq (Seq (TCNum n) Bool) p x y) (bvule n (bvOfSeq n x) (bvOfSeq n y));

ECNotEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECNotEq (Seq (TCNum n) Bool) p x y) (bvNe n (bvOfSeq n x) (bvOfSeq n y));

ECMinus_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PArith (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq (Seq (TCNum n) Bool) (ECMinus (Seq (TCNum n) Bool) p x y) (bvToSeq n (bvSub n (bvOfSeq n x) (bvOfSeq n y)));

ECZero_Seq_TCNum_Bool :: (n :: Nat) -> Eq (Seq (TCNum n) Bool) (ECZero (Seq (TCNum n) Bool)) (bvToSeq n (bvNat n 0));

--

ECast_same :: (a :: sort 0) -> (x :: a) -> Eq a (ECast a a x) x;

Seq_TCNum :: (n :: Nat) -> (a :: sort 0) -> Eq (sort 0) (Seq (TCNum n) a) (Vec n a);
Seq_TCNum_Bool :: (n :: Nat) -> Eq (sort 0) (Seq (TCNum n) Bool) (bitvector n);

subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

-- TODO: implement these rules more generally with conversions:
subNat_5_1 :: Eq Nat (subNat 5 1) 4;
widthNat_4 :: Eq Nat (widthNat 4) 3;
widthNat_5 :: Eq Nat (widthNat 5) 3;

--------------------------------------------------------------------------------
