--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

TCWidth :: Num -> Num;
TCLg2 :: Num -> Num;

TCAdd :: Num -> Num -> Num;
TCAdd (TCNum x) (TCNum y) = TCNum (addNat x y);
TCAdd (TCNum _) TCInf = TCInf;
TCAdd TCInf _ = TCInf;

TCSub :: Num -> Num -> Num;

TCMul :: Num -> Num -> Num;
TCMul (TCNum x) (TCNum y) = TCNum (mulNat x y);
TCMul (TCNum x) TCInf = ite Num (equalNat 0 x) (TCNum 0) TCInf;
TCMul TCInf (TCNum y) = ite Num (equalNat 0 y) (TCNum 0) TCInf;
TCMul TCInf TCInf = TCInf;

TCDiv :: Num -> Num -> Num;
TCMod :: Num -> Num -> Num;
TCExp :: Num -> Num -> Num;

TCMin :: Num -> Num -> Num;
TCMin (TCNum x) (TCNum y) = TCNum (minNat x y);
TCMin (TCNum x) TCInf = TCNum x;
TCMin TCInf (TCNum y) = TCNum y;
TCMin TCInf TCInf = TCInf;

TCMax :: Num -> Num -> Num;

TCLenFromThen :: Num -> Num -> Num -> Num;
TCLenFromThenTo :: Num -> Num -> Num -> Num;

--------------------------------------------------------------------------------
-- Possibly unbounded sequence indexes

Index :: Num -> sort 0;
Index (TCNum n) = Fin n;
Index TCInf = Nat;

indexMinL :: (m n :: Num) -> Index (TCMin m n) -> Index m;
indexMinR :: (m n :: Num) -> Index (TCMin m n) -> Index n;

indexSplit :: (m n :: Num) -> Index (TCMul m n) -> #(Index m, Index n);
indexFst :: (m n :: Num) -> Index (TCMul m n) -> Index m;
indexSnd :: (m n :: Num) -> Index (TCMul m n) -> Index n;

--------------------------------------------------------------------------------
-- Possibly infinite sequences

Seq :: Num -> sort 0 -> sort 0;
Seq (TCNum n) a = Vec n a;
Seq TCInf a = Nat -> a;
-- TODO: add infinite stream type to SAWCore prelude

make :: (n :: Num) -> (a :: sort 0) -> (Index n -> a) -> Seq n a;
make (TCNum n) a f = Prelude.generate n a f;
make TCInf a f = f;

peek :: (n :: Num) -> (a :: sort 0) -> Seq n a -> Index n -> a;
peek (TCNum n) a v i = Prelude.get n a v i;
peek TCInf a v i = v i;

bvToSeq :: (n :: Nat) -> bitvector n -> Seq (TCNum n) Bool;
bvToSeq n x = x;

bvOfSeq :: (n :: Nat) -> Seq (TCNum n) Bool -> bitvector n;
bvOfSeq n x = x;

vecToSeq :: (n :: Nat) -> (a :: sort 0) -> Vec n a -> Seq (TCNum n) a;
vecOfSeq :: (n :: Nat) -> (a :: sort 0) -> Seq (TCNum n) a -> Vec n a;

--------------------------------------------------------------------------------
-- Predicate symbols

KProp :: sort 1;
KProp = sort 0;

PEqual :: Num -> Num -> KProp;
PNeq   :: Num -> Num -> KProp;
PGeq   :: Num -> Num -> KProp;
PFin   :: Num -> KProp;
-- PHas Selector
PArith :: sort 0 -> KProp;
PCmp   :: sort 0 -> KProp;

Instance_PFin_TCNum :: (n :: Nat) -> PFin (TCNum n);

theNat :: (m :: Num) -> PFin m -> Nat;
--theNat _ (Instance_PFin_TCNum n) = n;

theVec :: (m :: Num) -> (a :: sort 0) -> (p :: PFin m) -> Seq m a -> Vec (theNat m p) a;
--theVec _ a (Instance_PFin_TCNum n) xs = vecOfSeq a n xs;

--------------------------------------------------------------------------------
-- Auxiliary functions

EProofApp :: (a :: KProp) -> a;
ECast :: (a b :: sort 0) -> a -> b;
EList :: (a :: sort 0) -> (n :: Nat) -> Vec n a -> Seq (TCNum n) a;
EListSel :: (a :: sort 0) -> (n :: Num) -> Seq n a -> Nat -> a;
EIf :: (a :: sort 0) -> Bool -> a -> a -> a;

--------------------------------------------------------------------------------
-- List comprehensions

-- TODO: use Prelude one
uncurry :: (a b c :: sort 0) -> (a -> b -> c) -> (#(a, b) -> c);
uncurry a b c f = (\(x :: #(a, b)) -> f (x.1) (x.2));

from :: (a b :: sort 0) -> (m n :: Num) -> Seq m a -> (a -> Seq n b) -> Seq (TCMul m n) #(a, b);
from a b m n xs f =
  make (TCMul m n) #(a, b)
    (\(i :: Index (TCMul m n)) ->
      (peek m a xs (indexFst m n i),
       peek n b (f (peek m a xs (indexFst m n i))) (indexSnd m n i)));

single :: (a :: sort 0) -> a -> Seq (TCNum 1) a;
single a x = make (TCNum 1) a (\(i :: Index (TCNum 1)) -> x);

mlet :: (a b :: sort 0) -> (n :: Num) -> a -> (a -> Seq n b) -> Seq n #(a, b);
mlet a b n x f = make n #(a, b) (\(i :: Index n) -> (x, peek n b (f x) i));

zip :: (a b :: sort 0) -> (m n :: Num) -> Seq m a -> Seq n b -> Seq (TCMin m n) #(a, b);
zip a b m n xs ys =
  make (TCMin m n) #(a, b)
    (\(i :: Index (TCMin m n)) ->
      (peek m a xs (indexMinL m n i), peek n b ys (indexMinR m n i)));

map :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> Seq n a -> Seq n b;
map a b n f xs = make n b (\(i :: Index n) -> f (peek n a xs i));

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ECDemote :: (val bits :: Num) -> PFin val -> PFin bits -> PGeq bits (TCWidth val) -> Seq bits Bool;

-- Arith
ECPlus  :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECMinus :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECMul   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECDiv   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECMod   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECExp   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ECLg2   :: (a :: sort 0) -> PArith a -> a -> a;
ECNeg   :: (a :: sort 0) -> PArith a -> a -> a;

-- Cmp
ECLt    :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ECGt    :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ECLtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ECGtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ECEq    :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ECNotEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;

ECFunEq    :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ECFunNotEq :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;

ECMin :: (a :: sort 0) -> PCmp a -> a -> a -> a;
ECMax :: (a :: sort 0) -> PCmp a -> a -> a -> a;

-- Logic
ECAnd   :: (a :: sort 0) -> a -> a -> a;
ECOr    :: (a :: sort 0) -> a -> a -> a;
ECXor   :: (a :: sort 0) -> a -> a -> a;
ECCompl :: (a :: sort 0) -> a -> a;
ECZero  :: (a :: sort 0) -> a;

-- Sequences
ECShiftL :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;
ECShiftR :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;
ECRotL   :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;
ECRotR   :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;

ECCat :: (m n :: Num) -> (a :: sort 0) -> PFin m -> Seq m a -> Seq n a -> Seq (TCAdd m n) a;
ECSplitAt :: (m n :: Num) -> (a :: sort 0) -> PFin m -> Seq (TCAdd m n) a -> #(Seq m a, Seq n a);
ECJoin    :: (m n :: Num) -> (a :: sort 0) -> PFin n -> Seq m (Seq n a) -> Seq (TCMul m n) a;
ECSplit   :: (m n :: Num) -> (a :: sort 0) -> PFin n -> Seq (TCMul m n) a -> Seq m (Seq n a);

ECReverse   :: (n :: Num) -> (a :: sort 0) -> PFin n -> Seq n a -> Seq n a;
ECTranspose :: (m n :: Num) -> (a :: sort 0) -> Seq m (Seq n a) -> Seq n (Seq m a);

ECAt :: (n :: Num) -> (a :: sort 0) -> (m :: Num) -> Seq n a -> Seq m Bool -> a;
ECAtRange :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> PFin i -> Seq n a -> Seq m (Seq i Bool) -> Seq m a;
ECAtBack :: (n :: Num) -> (a :: sort 0) -> (m :: Num) -> PFin n -> Seq n a -> Seq m Bool -> a;
ECAtRangeBack :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> PFin n -> Seq n a -> Seq m (Seq i Bool) -> Seq m a;

-- Static word sequences
ECFromThen :: (first next bits len :: Num) -> PFin first -> PFin next -> PFin bits
           -> PGeq bits (TCWidth first) -> PGeq bits (TCWidth next)
           -> PEqual (TCLenFromThen first next bits) len
           -> Seq len (Seq bits Bool);

ECFromTo :: (first last bits :: Num) -> PFin last -> PFin bits
         -> PGeq last first -> PGeq bits (TCWidth last)
         -> Seq (TCAdd (TCNum 1) (TCSub last first)) (Seq bits Bool);

-- Infinite word sequences
ECInfFrom     :: (n :: Num) -> PFin n -> Seq n Bool -> Seq TCInf (Seq n Bool);
ECInfFromThen :: (n :: Num) -> PFin n -> Seq n Bool -> Seq n Bool -> Seq TCInf (Seq n Bool);

-- Run-time error
ECError :: (a :: sort 0) -> (len :: Num) -> PFin len -> Seq len (Seq (TCNum 8) Bool) -> a;

-- Polynomials
ECPMul :: (a b :: Num) -> PFin a -> PFin b -> Seq a Bool -> Seq b Bool
       -> Seq (TCSub (TCMax (TCNum 1) (TCAdd a b)) (TCNum 1)) Bool;

ECPDiv :: (a b :: Num) -> PFin a -> PFin b
       -> Seq a Bool -> Seq b Bool -> Seq a Bool;

ECPMod :: (a b :: Num) -> PFin a -> PFin b
       -> Seq a Bool -> Seq (TCAdd (TCNum 1) b) Bool -> Seq b Bool;

-- Random values
ECRandom :: (a :: sort 0) -> Seq (TCNum 32) Bool -> a;


--------------------------------------------------------------------------------
-- Extra functions that appear after rewriting

widthNat :: Nat -> Nat;
subNat :: Nat -> Nat -> Nat;

bvOfSeq_bvToSeq ::
  (n :: Nat) -> (x :: bitvector n) -> Eq (bitvector n) (bvOfSeq n (bvToSeq n x)) x;

peek_make ::
  (n :: Num) -> (a :: sort 0) -> (f :: Index n -> a) -> (i :: Index n)
  -> Eq a (peek n a (make n a f) i) (f i);

peek_TCNum ::
  (n :: Nat) -> (a :: sort 0) -> (xs :: Seq (TCNum n) a) -> (i :: Index (TCNum n))
  -> Eq a (peek (TCNum n) a xs i) (get n a (vecOfSeq n a xs) i);

--peek (TCNum n) a v i = Prelude.get n a v i;
--peek TCInf a v i = v i;

--------------------------------------------------------------------------------
-- Rewrite rules


-- Num operations
TCAdd_TCNum :: (m n :: Nat) -> Eq Num (TCAdd (TCNum m) (TCNum n)) (TCNum (addNat m n));
TCSub_TCNum :: (m n :: Nat) -> Eq Num (TCSub (TCNum m) (TCNum n)) (TCNum (subNat m n));
TCWidth_TCNum :: (n :: Nat) -> Eq Num (TCWidth (TCNum n)) (TCNum (widthNat n));

-- Boolean operations
ECAnd_Bool :: Eq (Bool -> Bool -> Bool) (ECAnd Bool) and;
ECOr_Bool :: Eq (Bool -> Bool -> Bool) (ECOr Bool) or;

-- Bitvector operations
ECCompl_Seq_TCNum_Bool :: (n :: Nat) -> (x :: Seq (TCNum n) Bool)
  -> Eq (Seq (TCNum n) Bool) (ECCompl (Seq (TCNum n) Bool) x) (bvToSeq n (bvNot n (bvOfSeq n x)));

ECDemote_TCNum :: (m n :: Nat) -> (p1 :: PFin (TCNum m)) -> (p2 :: PFin (TCNum n)) -> (p3 :: PGeq (TCNum n) (TCWidth (TCNum m)))
  -> Eq (Seq (TCNum n) Bool) (ECDemote (TCNum m) (TCNum n) p1 p2 p3) (bvToSeq n (bvNat n m));

ECEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECEq (Seq (TCNum n) Bool) p x y) (bvEq n (bvOfSeq n x) (bvOfSeq n y));

ECGtEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECGtEq (Seq (TCNum n) Bool) p x y) (bvuge n (bvOfSeq n x) (bvOfSeq n y));

ECLt_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECLt (Seq (TCNum n) Bool) p x y) (bvult n (bvOfSeq n x) (bvOfSeq n y));

ECLtEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECLtEq (Seq (TCNum n) Bool) p x y) (bvule n (bvOfSeq n x) (bvOfSeq n y));

ECNotEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ECNotEq (Seq (TCNum n) Bool) p x y) (bvNe n (bvOfSeq n x) (bvOfSeq n y));

ECMinus_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PArith (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq (Seq (TCNum n) Bool) (ECMinus (Seq (TCNum n) Bool) p x y) (bvToSeq n (bvSub n (bvOfSeq n x) (bvOfSeq n y)));

ECZero_Seq_TCNum_Bool :: (n :: Nat) -> Eq (Seq (TCNum n) Bool) (ECZero (Seq (TCNum n) Bool)) (bvToSeq n (bvNat n 0));

--

ECast_same :: (a :: sort 0) -> (x :: a) -> Eq a (ECast a a x) x;

Seq_TCNum :: (n :: Nat) -> (a :: sort 0) -> Eq (sort 0) (Seq (TCNum n) a) (Vec n a);
Seq_TCNum_Bool :: (n :: Nat) -> Eq (sort 0) (Seq (TCNum n) Bool) (bitvector n);

subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

-- TODO: implement these rules more generally with conversions:
subNat_5_1 :: Eq Nat (subNat 5 1) 4;
widthNat_4 :: Eq Nat (widthNat 4) 3;
widthNat_5 :: Eq Nat (widthNat 5) 3;

--------------------------------------------------------------------------------
