module Prelude where

-- Grammar for the core prelude types.
--
-- We use double colons "::" to represent the type constraint on the core symbols.
--   e.g., "Bool :: sort 0" indicates "Bool" has type "sort 0"
-- Functions use "->" to separate arguments from result.
--   e.g., "f :: Bool -> Bool -> Bool"indicates "f" is a binary operation on Booleans.
--
-- Single colons ":" are used for for scoping variables to be used in subsequent arguments.
--   "f :: n : Integer -> Signed n -> Signed n"
-- This  indicates "f" is a function that takes an integer argument "n", and returns a function
-- that takes "n"-bit signed integer and returns another "n"-bit signed integer.
--
-- We prefix the parameter with a single question mark (e.g., "?(n : Integer)") to indicate
-- the parameter is not passed explicitly, but should be inferred by type unification.
--
-- We prefix the parameter with two question marks (e.g., "??(Ord a)") to indicate the
-- parameter is not passed explicitly, but should be obtained by finding a unique term with
-- that type in the surrounding context.  If there are multiple such terms, then fail.
--
-- We use a parameter with three question marks (e.g., "???(assert (eq x y))") to denote
-- parameters that are not explicitly passed, but must be found to show that the expression
-- is well formed.  This is used to ensure the index is valid when reading or updating an array.

-- Equality proofs.

data Eq :: (t :: sort 1) -> t -> t -> sort 1 where {
    Refl :: (u :: sort 1) -> (x :: u) -> Eq u x x;
  }

trans :: (a :: sort 1) -> (x y z :: a) -> Eq a x y -> Eq a y z -> Eq a x z;
trans _ _ _ _ (Refl _ _) eq = eq;

-- Booleans
data Bool :: sort 0 where {
    True :: Bool;
    False :: Bool;
  }

not :: Bool -> Bool;
not (True) = False;
not (False) = True;

-- Could be derived from data declaration.
ite :: ?(a :: sort 0) -> Bool -> a -> a -> a;
ite _ (True)  t _ = t;
ite _ (False) _ f = f;

-- Pairs
fst :: (x y :: sort 0) -> #(x,y) -> x;
fst x y (l,h) = l;

snd :: (x y :: sort 0) -> #(x,y) -> y;
snd x y (l,h) = h;

-- Either

data Either :: sort 0 -> sort 0 -> sort 0 where {
    Left  :: (s t :: sort 0) -> s -> Either s t;
    Right :: (s t :: sort 0) -> t -> Either s t;
  }

eitherCong0 :: (t x y :: sort 0) -> Eq (sort 0) x y -> Eq (sort 0) (Either x t) (Either y t);
eitherCong0 t x _ (Refl _ _) = Refl (sort 0) (Either x t);

eitherCong1 :: (t x y :: sort 0) -> Eq (sort 0) x y -> Eq (sort 0) (Either t x) (Either t y);
eitherCong1 t x _ (Refl _ _) = Refl (sort 0) (Either t x);

-- Nat
data Nat :: sort 0 where {
    Zero :: Nat;
    Succ :: Nat -> Nat;
  }

eqNat :: Nat -> Nat -> sort 1;
eqNat x y = Eq Nat x y;

eqNatSucc :: (x y :: Nat) -> eqNat x y -> eqNat (Succ x) (Succ y);
eqNatSucc _ _ (Refl _ x) = Refl Nat (Succ x);

eqNatPrec :: (x y :: Nat) -> eqNat (Succ x) (Succ y) -> eqNat x y;
eqNatPrec _ _ (Refl _ (Succ x)) = Refl Nat x;

addNat :: Nat -> Nat -> Nat; 
addNat x (Zero) = x;
addNat x (Succ y) = Succ (addNat x y);

eqNatAdd0 :: (x :: Nat) -> eqNat (addNat 0 x) x;
eqNatAdd0 (Zero) = Refl Nat 0;
eqNatAdd0 (Succ x) = eqNatSucc (addNat 0 x) x (eqNatAdd0 x);

eqNatAddS :: (x y :: Nat) -> eqNat (addNat (Succ x) y) (Succ (addNat x y));
eqNatAddS x (Zero) = Refl Nat (Succ x);
eqNatAddS x (Succ y) = eqNatSucc (addNat (Succ x) y) (Succ (addNat x y)) (eqNatAddS x y);

eqNatAddComm :: (x y :: Nat) -> eqNat (addNat x y) (addNat y x);
eqNatAddComm (Zero) y = eqNatAdd0 y;
eqNatAddComm (Succ x) y = 
  trans Nat
        (addNat (Succ x) y)
        (Succ (addNat x y))
        (Succ (addNat y x))
        (eqNatAddS x y)
        (eqNatSucc (addNat x y) (addNat y x) (eqNatAddComm x y));

mulNat :: Nat -> Nat -> Nat;
mulNat x (Zero) = 0;
mulNat x (Succ y) = addNat x (mulNat x y);

data LeqNat :: Nat -> Nat -> sort 0 where {
    LeqNatProof :: (x y :: Nat) -> LeqNat x (addNat x y);
  }

leqN :: (x :: Nat) -> LeqNat x x;
leqN x = LeqNatProof x Zero;

data NatOrdering :: (x y :: Nat) -> sort 0 where {
    LeNatOrd :: (x z :: Nat) -> NatOrdering x (addNat z x);
    GtNatOrd :: (x z :: Nat) -> NatOrdering (addNat (Succ z) x) x;  
  }

natOrderingCong1 :: (x y z :: Nat) -> eqNat x y -> NatOrdering x z -> NatOrdering y z;
natOrderingCong2 :: (x y z :: Nat) -> eqNat x y -> NatOrdering z x -> NatOrdering z y;

succNatOrdering :: (x y :: Nat) -> NatOrdering x y -> NatOrdering (Succ x) (Succ y);
succNatOrdering _ _ (LeNatOrd x d) = LeNatOrd (Succ x) d;
succNatOrdering _ _ (GtNatOrd x d) = GtNatOrd (Succ x) d;

compareNat :: (x y :: Nat) -> NatOrdering x y;
compareNat (Zero) y = LeNatOrd Zero y;
compareNat (Succ x) (Zero) = GtNatOrd Zero x;
compareNat (Succ x) (Succ y) = succNatOrdering x y (compareNat x y);

-- Unchecked assertion that two types are equal.
assert :: (a :: sort 1) -> (x :: a) -> (y :: a) -> Eq a x y;

rcoerce :: (y x :: sort 0) -> Eq (sort 0) y x -> x -> y;
unsafeCoerce :: (y x :: sort 1) -> x -> y;

--TODO


-- There are implicit constructors from integer literals.

-- | Natural numbers less than a given bound.
data Fin :: (n :: Nat) -> sort 0 where {
    FinVal :: (x r :: Nat) -> Fin (Succ (addNat r x));
  }

finCong :: (m n :: Nat) -> Eq Nat m n -> Eq (sort 0) (Fin m) (Fin n);
finCong _ _ (Refl _ v) = Refl (sort 0) (Fin v);

incFin :: (n :: Nat) -> Fin n -> (i :: Nat) -> Fin (addNat i n); 
incFin _ (FinVal b r) i =
  unsafeCoerce (Fin (Succ (addNat i (addNat r b))))
               (Fin (Succ (addNat r (addNat i b))))
               (FinVal (addNat i b) r);

leqFin :: (m :: Nat) -> Fin m -> (n :: Nat) -> LeqNat m n -> Fin n;
leqFin _ (FinVal x r) _ (LeqNatProof _ d) =
  unsafeCoerce (Fin (addNat (Succ (addNat r x)) d))
               (Fin (Succ (addNat (addNat r d) x)))
               (FinVal x (addNat r d));

finSplitSum :: (m n :: Nat) -> Fin (addNat m n) -> Either (Fin m) (Fin n);
finSplitSum m n = 
  let { go :: (x :: Nat) -> eqNat (addNat n m) x -> Fin x -> Either (Fin m) (Fin n);
        go _ eq (FinVal v r) = finSplitSum2 n 0 v m r eq;
      }
   in go (addNat m n) (eqNatAddComm n m);

finSplitSum2 :: (n :: Nat)
             -> (i :: Nat) -- How many times we have iterated.
             -> (v :: Nat) -- How much of initial value remains.
             -> (m :: Nat) -- How much of m remains
             -> (r :: Nat) -- Initial remainer.
             -> eqNat (addNat n m) (Succ (addNat r v))
             -> Either (Fin (addNat m i)) (Fin n);
finSplitSum2 n i v (Zero) r eq =
  Right (Fin (addNat (Zero) i)) (Fin n)
        (rcoerce (Fin n)
                 (Fin (Succ (addNat r v)))
                 (finCong n (Succ (addNat r v)) eq)
                 (FinVal v r));
finSplitSum2 n i (Zero) (Succ p) _ _ =
  Left (Fin (addNat (Succ p) i)) (Fin n)
       (rcoerce (Fin (addNat (Succ p) i))
               (Fin (Succ (addNat p i)))
               (finCong (addNat (Succ p) i) (Succ (addNat p i))
                 (eqNatAddS p i))
               (FinVal i p));
finSplitSum2 n i (Succ v) (Succ p) r eq =
  rcoerce (Either (Fin (addNat (Succ p) i)) (Fin n))
          (Either (Fin (Succ (addNat p i))) (Fin n))          
          (eitherCong0 (Fin n)
                       (Fin (addNat (Succ p) i))
                       (Fin (Succ (addNat p i)))
                       (finCong (addNat (Succ p) i) (Succ (addNat p i))
                         (eqNatAddS p i)))
          (finSplitSum2 n (Succ i) v p r
            (eqNatPrec (addNat n p) (Succ (addNat r v)) eq));

finProduct :: (m :: Nat) -> Fin m -> (n :: Nat) -> Fin n -> Fin (mulNat m n);
finProduct _ (FinVal mv mr) _ (FinVal nv nr) =
  rcoerce (Fin (mulNat (Succ (addNat mr mv)) (Succ (addNat nr nv))))
          (Fin (Succ (addNat (addNat (mulNat mr (Succ (addNat nv nr))) nr)
                     (addNat (mulNat mv (Succ (addNat nv nr))) nv))))
          (finCong (mulNat (Succ (addNat mr mv)) (Succ (addNat nr nv)))
                   (Succ (addNat (addNat (mulNat mr (Succ (addNat nv nr))) nr)
                         (addNat (mulNat mv (Succ (addNat nv nr))) nv)))
                   (assert Nat (mulNat (Succ (addNat mr mv)) (Succ (addNat nr nv)))
                               (Succ (addNat (addNat (mulNat mr (Succ (addNat nv nr))) nr)
                                             (addNat (mulNat mv (Succ (addNat nv nr))) nv)))))
          (FinVal (addNat (mulNat mv (Succ (addNat nv nr))) nv)
                  (addNat (mulNat mr (Succ (addNat nv nr))) nr));

finSplitProduct :: (m n :: Nat) -> Fin (mulNat m n) -> #(Fin m, Fin n);
--TODO

-- "Vec n a" is an array of n elements, each with type "a".
data Vec :: (n :: Nat) -> sort 1 -> sort 1 where {
  }
--TODO

-- Function for generating an array.
generate :: (n :: Nat) -> (e :: sort 1) -> (Fin n -> e) -> Vec n e;
--TODO

-- Get and set an individual element in an array.
get :: (n :: Nat) -> (e :: sort 1) -> Vec n e -> Fin n -> e;
--TODO

set :: (n :: Nat) -> (e :: sort 1) -> Vec n e -> Fin n -> e -> Vec n e;
--TODO

-- | Select a range [i,..,i+n] of values from the array.
select :: (l :: Nat) -> (i n :: Nat) -> (e :: sort 0)
       -> LeqNat (addNat i n) l
       -> Vec l e -> Vec n e;
select l i n e lh a = 
  let { eltFn :: Fin n -> e;
        eltFn j = get l e a (leqFin (addNat i n) (incFin n j i) l lh);
      }
   in generate n e eltFn;

-- | Defines a function that maps array elements from one range to another.
mapVec :: (n :: Nat) -> (s t :: sort 0) -> (s -> t) -> Vec n s -> Vec n t;
mapVec n s t f v = generate n t (\(i :: Fin n) -> get n s v i);

-- replicate n x returns an array with n copies of x.
replicate :: (n :: Nat)
          -> ?(e :: sort 0) -> e -> Vec n e;
replicate n e v = generate n e (\(_ :: Fin n) -> v);

-- Concatenate arrays together.
join  :: (m n :: Nat)
       -> (e :: sort 0)
       -> Vec m (Vec n e)
       -> Vec (mulNat m n) e;
join m n e a =
  let { eltFn :: Fin (mulNat m n) -> e;
        eltFn i = splitFn (finSplitProduct m n i);
        splitFn :: #(Fin m, Fin n) -> e;
        splitFn (i,j) = get n e (get ?m ?(Vec n e) a i) j;
      }
   in generate (mulNat m n) e eltFn;

-- Split array into list
split :: ?(m n :: Nat) -> ?(e :: sort 0) -> Vec (mulNat m n) e -> Vec m (Vec n e);
split  m n e a =
  let { arrayFn :: Fin m -> Vec n e;
        arrayFn i =
         let { eltFn :: Fin n -> e;
               eltFn j = get (mulNat m n) e a (finProduct m i n j);
             }
          in generate n ?e eltFn;
      }
   in generate m ?(Vec n e) arrayFn;

-- Append two arrays together.
append :: (m n :: Nat) -> (e :: sort 0) 
       -> Vec m e -> Vec n e -> Vec (addNat m n) e;
append m n e x y =
  let { eltFn :: Fin (addNat m n) -> e;
        eltFn i = compareFn (finSplitSum m n i);

        compareFn :: Either (Fin m) (Fin n) -> e;
        compareFn (Left _ _ i)  = get m e x i;
        compareFn (Right _ _ i) = get n e y i;
      }
   in generate (addNat m n) e eltFn;

bitvector :: (n :: Nat) -> sort 1;
bitvector n = Vec n Bool;

-- | Convert between two signed representations.
-- This is implemented by using arrays so that the result can still be bit-blasted.
resizeSigned :: ?(x y :: Nat)
             -> bitvector (Succ x) -> bitvector (Succ y);
-- Simple definition (if bit-blasting doesn't matter)
-- signedToSigned s = integerToSigned (signedToInteger s)
-- Complex definition (supports bit-blasting).
resizeSigned x y s =
  let { compareFn :: (x y :: Nat) -> bitvector (Succ x) -> NatOrdering y x -> bitvector (Succ y); 
        compareFn _ _ a (LeNatOrd l d) =
          select (Succ (addNat d l)) d (Succ l) Bool (leqN (Succ (addNat d l))) a;
        compareFn _ _ a (GtNatOrd l d) =
          let { msb :: Bool;
                msb = get (Succ l) Bool a (FinVal 0 l);
                padding :: bitvector (Succ d);
                padding = replicate (Succ d) Bool msb;
              }
           in (append (Succ d) (Succ l) ?Bool padding a);
      }
   in compareFn x y s (compareNat y x);

-- | An array where each element may have a different type.
data Tuple :: (n :: Nat) -> (tps :: Vec n (sort 0)) -> sort 0 where {
    MkTuple :: (n :: Nat)
            -> (tps :: Vec n (sort 0))
            -> ((i :: Fin n) -> get n (sort 0) tps i)
            -> Tuple n tps;
  }

data Double :: sort 0 where { }

data Float :: sort 0 where { }