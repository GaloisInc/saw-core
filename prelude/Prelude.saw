module Prelude where

-- Grammar for the core prelude types.
--
-- We use double colons "::" to represent the type constraint on the core symbols.
--   e.g., "Bool :: sort 0" indicates "Bool" has type "sort 0"
-- Functions use "->" to separate arguments from result.
--   e.g., "f :: Bool -> Bool -> Bool"indicates "f" is a binary operation on Booleans.
--
-- Single colons ":" are used for for scoping variables to be used in subsequent arguments.
--   "f :: n : Integer -> Signed n -> Signed n"
-- This  indicates "f" is a function that takes an integer argument "n", and returns a function
-- that takes "n"-bit signed integer and returns another "n"-bit signed integer.
--
-- We prefix the parameter with a single question mark (e.g., "?(n : Integer)") to indicate
-- the parameter is not passed explicitly, but should be inferred by type unification.
--
-- We prefix the parameter with two question marks (e.g., "??(Ord a)") to indicate the
-- parameter is not passed explicitly, but should be obtained by finding a unique term with
-- that type in the surrounding context.  If there are multiple such terms, then fail.
--
-- We use a parameter with three question marks (e.g., "???(assert (eq x y))") to denote
-- parameters that are not explicitly passed, but must be found to show that the expression
-- is well formed.  This is used to ensure the index is valid when reading or updating an array.

-- Booleans
data Bool :: sort 0 where {
    True :: Bool;
    False :: Bool;
  }

eq :: ?(a :: sort 0) -> a -> a -> Bool;

not :: Bool -> Bool;

-- Could be derived from data declaration.
ite :: ?(a :: sort 0) -> Bool -> a -> a -> a;

-- Pairs
fst :: (x y :: sort 0) -> #(x,y) -> x;
fst x y (l,h) = l;

snd :: (x y :: sort 0) -> #(x,y) -> y;
snd x y (l,h) = h;

-- Ordering "typeclass"
data Ord :: sort 0 -> sort 0 where {
   OrdInstance :: ?(a :: sort 0)
               -> (a -> a -> Bool) -- Less-than-or-equal function.
               -> Ord a;
  }

leq :: ?(a :: sort 0) -> ??(Ord a) -> a -> a -> Bool;
leq _ ??(OrdInstance a f) = f;

lt  :: ?(a :: sort 0) -> ??(Ord a) -> a -> a -> Bool;
lt _ ??(OrdInstance a f) x y = not (leq y x);

--geq :: ?(a :: sort 0) -> ??(Ord a) -> a -> a -> Bool;
--geq ??(OrdInstance f) x y = leq y x;

--gt  :: ?(a :: sort 0) -> ??(Ord a) -> a -> a -> Bool;
--gt ??(OrdInstance f) x y = not (leq x y);

-- False becomes before true.
boolOrdInstance :: Ord Bool;

-- Numeric operations.
data Num :: sort 0 -> sort 0 where {
   NumInstance 
         :: ?(a :: sort 0)
         -- Predicate reducing to TrueProp if we can divide input by zero, and false otherwise.
         -> (nonZero :: a -> sort 0)     
         -> #{ neg :: a -> a;
               add :: a -> a -> a;
               sub :: a -> a -> a;
               mul :: a -> a -> a;
               div :: a -> (y::a) -> ???(nonZero y) -> a;
               mod :: a -> (y::a) -> ???(nonZero y) -> a;
             }
         -> Num a;
  }

nonZero :: ?(a :: sort 0) -> ??(Num a) -> a -> sort 0;
nonZero _ ??(NumInstance a nz r) = nz;

neg :: ?(a :: sort 0) -> ??(Num a) -> a -> a;
neg _ ??(NumInstance a nz r) = r.neg;

add :: ?(a :: sort 0) -> ??(Num a) -> a -> a -> a;
add _ ??(NumInstance a nz r) = r.add;

sub :: ?(a :: sort 0) -> ??(Num a) -> a -> a -> a;
sub _ ??(NumInstance a nz r) = r.sub;

mul :: ?(a :: sort 0) -> ??(Num a) -> a -> a -> a;
mul _ ??(NumInstance a nz r) = r.mul;

div :: ?(a :: sort 0) -> ??(r::Num a) -> a -> (y::a) -> ???(nonZero ?a ??r y) -> a;
div _ ??(NumInstance a nz r) = r.div;

mod :: ?(a :: sort 0) -> ??(r::Num a) -> a -> (y::a) -> ???(nonZero ?a ??r y) -> a;
mod _ ??(NumInstance a nz r) = r.mod;

data Bits :: sort 0 -> sort 0 where {
   BitsInstance :: ?(a :: sort 0)
                -> #{ not     :: a -> a;
                      and     :: a -> a -> a;
                      or      :: a -> a -> a;
                      xor     :: a -> a -> a;
                      implies :: a -> a -> a;
                      shl     :: a -> a -> a;
                      shr     :: a -> a -> a;
                    }
                -> Bits a;
  }


--not :: ?(a :: sort 0) -> ??(Bits a) -> a -> a;
--not _ ??(BitsInstance a r) = r.not;
--
--and :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
--and _ ??(BitsInstance a r) = r.and;
--
--or :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
--or _ ??(BitsInstance a r) = r.or;
--xor :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
--xor _ ??(BitsInstance a r) = r.xor;
--
--implies :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
--implies _ ??(BitsInstance a r) = r.imples;
--
--shl :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
--shl _ ??(BitsInstance a r) = r.shl;
--
--shr :: ?(a :: sort 0) -> ??(Bits a) -> a -> a -> a;
--shr _ ??(BitsInstance a r) = r.shr;
--
--boolBitsInstance :: Bits Bool;

-- Nat
data Nat :: sort 0 where {
    Zero :: Nat;
    Succ :: Nat -> Nat;
  }

data LeqNat :: Nat -> Nat -> sort 0 where {
  }

leqSucc :: (x y :: Nat) -> LeqNat x y -> LeqNat (Succ x) (Succ y);

data LtNat :: Nat -> Nat -> sort 0 where {
  }

lt0Succ :: (x :: Nat) -> LtNat 0 (Succ x);
ltNatToLeqNat :: (x y :: Nat) -> LtNat x y -> LeqNat x y;

-- | Compares two integers and perform appropriate action.
iteLtNat :: (a :: sort 0)
         -> (x y :: Nat)
         -> (LtNat x y -> a)
         -> (LeqNat y x -> a);

addNat :: Nat -> Nat -> Nat; 

leqAdd0 :: (x y :: Nat) -> LeqNat x y -> LeqNat (addNat 0 x) y;
ltNatAddBounded :: (i n j l :: Nat)
                -> LeqNat (addNat i n) l
                -> LtNat j n
                -> LtNat (addNat i j) l;

subNat :: (x y :: Nat) -> LeqNat y x -> Nat;

ltSubNat :: (x y z :: Nat)
         -> (p :: LeqNat y x)
         -> LtNat x (addNat y z)
         -> LtNat (subNat x y p) z;

mulNat :: Nat -> Nat -> Nat;
lt0NatMul2 :: (n i m :: Nat) -> LtNat i (mulNat m n) -> LtNat 0 n;
ltNatPair :: (i m j n :: Nat)
           -> LtNat i m
           -> LtNat j n
           -> LtNat (addNat (mulNat i n) j) (mulNat m n);


divNat :: Nat -> (y::Nat) -> LtNat 0 y -> Nat;
ltNatDiv :: (i m n :: Nat)
         -> (p :: LtNat 0 n)
         -> LtNat i (mulNat m n)
         -> LtNat (divNat i n p) m;

modNat :: Nat -> (y::Nat) -> LtNat 0 y -> Nat;
ltNatMod :: (i n :: Nat) -> (p :: LtNat 0 n) -> LtNat (modNat i n p) n;

-- Integers
data Integer :: sort 0 where {
  }

-- There are implicit constructors from integer literals.
integerOrdInstance  :: Ord  Integer;
integerNumInstance  :: Num  Integer;
integerBitsInstance :: Bits Integer;

-- "Array n a" is an array of n elements, each with type "a".
data Array :: (n :: Nat) -> sort 1 -> sort 1 where {
  }

-- Get and set an individual element in an array.
-- The assertions are used to ensure that get and set are given valid arguments.
get :: ?(n :: Nat) -> ?(e :: sort 1)
    -> Array n e -> (i::Nat) -> ???(LtNat i n) -> e;
set :: ?(n :: Nat) -> ?(a :: sort 1)
    -> Array n a -> (i::Nat) -> ???(LtNat i n) -> a
    -> Array n a;

-- Function for generating an array.
generate :: (n :: Nat)
         -> ?(e :: sort 1)
         -> ((i :: Nat) -> ???(LtNat i n) -> e) 
         -> Array n e;

-- | Select a range [i,..,i+n] of values from the array.
select :: ?(l :: Nat) -> (i n :: Nat) -> ?(e :: sort 0)
       -> LeqNat (addNat i n) l
       -> Array l e -> Array n e;
select ?l i n ?e lh a = 
  let { eltFn :: (j :: Nat) -> LtNat j n -> e;
        eltFn j jh = get l ?e a (add i j) (ltNatAddBounded i n j l lh jh);
      }
   in generate n ?e eltFn;

-- | Defines a function that maps array elements from one range to another.
mapArray :: (s t :: sort 0) -> (s -> t)  -> (n :: Nat) -> Array n s -> Array n t;
{-
mapArray = undefined
-}

-- replicate n x returns an array with n copies of x.
replicate :: (n :: Nat)
          -> ?(e :: sort 0) -> e -> Array n e;
replicate n e v =
  let { eltFn :: (j :: Nat) -> LtNat j n -> e;
        eltFn j p = v;
      }
   in generate n e eltFn;

-- Concatenate arrays together.
join  :: (m n :: Nat)
      -> (e :: sort 0)
      -> Array m (Array n e)
      -> Array (mulNat m n) e;
join m n e a =
  let { eltFn :: (i :: Nat) -> LtNat i (mulNat m n) -> e;
        eltFn i ih = 
          let { nNZ :: LtNat 0 Nat;
                nNZ = lt0NatMul2 n i m ih;
                a1 :: Array n e;
                a1 = get ?m ?(Array n e) a (divNat i n nNZ) (ltNatDiv i m n nNZ ih);
              }
           in get ?n ?e a1 (modNat i n nNZ) (ltNatMod i n nNZ);
      }
   in generate (mulNat m n) e eltFn;

-- Split array into list
split :: ?(m n :: Nat) -> ?(e :: sort 0) -> Array (mul m n) e -> Array m (Array n e);
split ?m ?n ?e a =
  let { arrayFn :: (i::Nat) -> LtNat i m -> Array n e;
        arrayFn i ih =
         let { eltFn :: (j :: Nat) -> LtNat j n -> e;
               eltFn j jh = get ?(mulNat m n) ?e a
                                (addNat (mulNat i n) j)
                                (ltNatPair i m j n ih jh);
             }
          in generate n ?e eltFn;
      }
   in generate m ?(Array n e) arrayFn;

-- Append two arrays together.
append :: ?(m n :: Nat) -> ?(e :: sort 0) 
       -> Array m e -> Array n e -> Array (addNat m n) e;
append ?m ?n ?e x y =
  let { ltFn :: (i :: Nat) -> LtNat i m -> e;
        ltFn i p = get ?m ?e x i p;
        leqFn :: (i :: Nat) -> LtNat i (addNat m n) -> LeqNat m i -> e;
        leqFn i ih p = get ?n ?e y (subNat i m p) (ltSubNat i m n p ih);
        eltFn :: (i :: Nat) -> LtNat i (addNat m n) -> e;
        eltFn i ih = iteLtNat e i m (ltFn i) (leqFn i ih);
      }
   in generate (addNat m n) ?e eltFn;

-- "Signed n" and "Unsigned n" represent bitvectors with length n
-- representing signed and unsigned integers.
data Signed :: (n :: Nat) -> sort 0 where {
  }

data Unsigned :: (n :: Nat) -> sort 0 where {
  }

-- These are equivalent to arrays of Booleans, but can perform arithmetic.
signedOrdInstance    :: ?(n :: Nat) -> Ord (Signed (Succ n));
signedNumInstance    :: ?(n :: Nat) -> Num (Signed (Succ n));
signedBitsInstance   :: ?(n :: Nat) -> Bits (Signed (Succ n));
unsignedOrdInstance  :: ?(n :: Nat) -> Ord (Unsigned n);
unsignedNumInstance  :: ?(n :: Nat) -> Num (Unsigned n);
unsignedBitsInstance :: ?(n :: Nat) -> Bits (Unsigned n);

-- Convert between bitvectors and integers.
signedToInteger   :: ?(n :: Nat) -> Signed (Succ n) -> Integer;
integerToSigned   :: ?(n :: Nat) -> Integer -> Signed (Succ n);

unsignedToInteger :: ?(n :: Nat) -> Unsigned n -> Integer;
integerToUnsigned :: ?(n :: Nat) -> Integer -> Unsigned n;

-- Convert between bitvectors and arrays of bits.
-- Integers are stored with most-significant bit first (aka. in byte 0).
signedToArray   :: ?(n :: Nat) -> Signed (Succ n) -> Array (Succ n) Bool;
arrayToSigned   :: ?(n :: Nat) -> Array (Succ n) Bool -> Signed (Succ n);

unsignedToArray :: ?(n :: Nat) -> Unsigned n   -> Array n Bool;
arrayToUnsigned :: ?(n :: Nat) -> Array n Bool -> Unsigned n;

-- | Convert between two signed representations.
-- This is implemented by using arrays so that the result can still be bit-blasted.
resizeSigned :: ?(x y :: Nat)
             -> Signed (Succ x) -> Signed (Succ y);
-- Simple definition (if bit-blasting doesn't matter)
-- signedToSigned s = integerToSigned (signedToInteger s)
-- Complex definition (supports bit-blasting).
resizeSigned ?x ?y s =
  let { a :: Array (Succ x) Bool;
        a = signedToArray ?x s;
        ltFn :: LtNat y x -> Array (Succ y) Bool;
        ltFn p = 
           let { pLeq :: LeqNat y x;
                 pLeq = ltNatToLeqNat y x p;
                 pSucc :: LeqNat (Succ y) (Succ x);
                 pSucc = leqSucc y x pLeq;
                 pAdd0 :: LeqNat (addNat 0 (Succ y)) (Succ x);
                 pAdd0 = leqAdd0 (Succ y) (Succ x) pSucc;
               }
            in select (Succ x) 0 (Succ y) ?Bool pAdd0 a;
        leqFn :: LeqNat x y -> Array (Succ y) Bool;
        leqFn p = 
          let { z :: Nat;
                z = subNat y x p;
                msb :: Bool;
                msb = get (Succ ?x) ?Bool a 0 (lt0Succ x);
                padding :: Array (subNat y x p) Bool;
                padding = replicate z Bool msb;
              }
           in append ?(subNat y x p) ?x ?Bool padding a;
      }
   in arrayToSigned ?y (iteLtNat (Array (Succ y) Bool) y x ltFn leqFn);

signedToUnsigned :: ?(x :: Nat) -> Signed (Succ x) -> Unsigned (Succ x);
unsignedToSigned :: ?(x :: Nat)
                 -> Unsigned (Succ x)
                 -> Signed (Succ x);

-- Performs a signed shift right as an unsigned shift right.
signedUShr :: ?(n :: Nat) -> Signed (Succ n) -> Signed (Succ n) -> Signed (Succ n);
-- TODO: Add definition.

-- Performs the Java long compare operation.
javaLongCompare :: Signed 64 -> Signed 64 -> Signed 32;
-- TODO: Add definition.

-- | An array where each element may have a different type.
data Tuple :: (n :: Nat) -> (tps :: Array n (sort 0)) -> sort 0 where {
    MkTuple :: (n :: Nat)
            -> (tps :: Array n (sort 0))
            -> ((i :: Nat) -> (p :: LtNat i n) -> get n (sort 0) tps i p)
            -> Tuple n tps;
  }

data Double :: sort 0 where { }

data Float :: sort 0 where { }